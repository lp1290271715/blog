(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{354:function(t,n,a){"use strict";a.r(n);var e=a(43),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript-你不知道的立即执行函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-你不知道的立即执行函数"}},[t._v("#")]),t._v(" JavaScript-你不知道的立即执行函数")]),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("最近闲暇时间看了腾讯课堂"),a("a",{attrs:{href:"https://ke.qq.com/course/231577?taid=1464781416663193",target:"_blank",rel:"noopener noreferrer"}},[t._v("渡一教育-JavaScript权威课堂"),a("OutboundLink")],1),t._v("的视频，感觉受益颇多，因此记录一下课上所学，有时间的话观看视频效果更佳哦，没时间也可以看看小弟的总结，保证干货满满。")]),t._v(" "),a("h2",{attrs:{id:"立即执行函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#立即执行函数"}},[t._v("#")]),t._v(" 立即执行函数")]),t._v(" "),a("p",[t._v("立即执行函数是JavaScript中唯一一种可以主动释放函数作用域的方式，即一个立即执行函数执行完成之后就会被销毁。\n实现如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 写法1：（w3c的推荐写法）\n(function(){\n    var num = 123\n    console.log(123) //123\n}())\n\n// 写法2\n(function(){\n    var num = 123\n    console.log(123) // 123\n})()\n\n")])])]),a("h2",{attrs:{id:"你不知道的事"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你不知道的事"}},[t._v("#")]),t._v(" 你不知道的事")]),t._v(" "),a("p",[t._v("立即执行函数其实并不是系统故意设定的的一种语法，而是基于以下规则，并在后续程序猿们的探索下衍生出来的一种东西。")]),t._v(" "),a("h3",{attrs:{id:"规则1：-只有表达式才能用执行符号（也就是-）执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#规则1：-只有表达式才能用执行符号（也就是-）执行"}},[t._v("#")]),t._v(" 规则1： 只有表达式才能用执行符号（也就是()）执行")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// example 1：\n// result   : Uncaught SyntaxError: Unexpected token ')'\nfunction fn(){\n    console.log(123)\n}()\n// 原因：function test(){} 是一个函数申明，并不是表达式，所以不能使用()执行，会报语法错误\n\n// example 2: \n// result   : 123\nvar fn = function(){\n    console.log(123)\n}()\n// 原因：var fn = function(){} 是一个函数表达式，可以使用()执行，打印出123\n")])])]),a("p",[t._v("看到这里可能有"),a("strong",[t._v("杠友")]),t._v("就会开始"),a("strong",[t._v("抬杠")]),t._v("了：")]),t._v(" "),a("p",[a("strong",[t._v("抬杠一：")]),t._v(" 既然只有表达式能被执行，那为什么fn()这样也能执行函数呢？？")]),t._v(" "),a("p",[a("strong",[t._v("杠回去：")]),t._v(" fn()中的fn其实也是一个表达式")]),t._v(" "),a("p",[a("strong",[t._v("抬杠二：")]),t._v(" 既然表达式能被执行符号执行，那(1+1)()这样为什么会报错呢？？")]),t._v(" "),a("p",[a("strong",[t._v("杠回去：")]),t._v(" 这位杠友请注意一个细节，在咱们上述example 1 里面报的错误是语法错误，也就是说系统并不能识别这种写法，即非表达式并不能被执行。而下面这个例子报的错是类型错误，也就是说系统认为这个语句是合法的，1+1计算出的结果是2，2也是一个表达式，后面加()可执行，但是由于2并不是一个函数，所以报错TypeError，并提示其不是一个函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(1 + 1)() //Uncaught TypeError: 2 is not a function\n")])])]),a("p",[t._v("经过一轮抬杠，大家可能对上述的规则一印象更加深刻了，咱们再趁热打铁一下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// example 3 :\n// result    : 123\n+ function fn(){\n   console.log(123) \n}()\n// 同上\n- function fn(){\n    console.log(123)\n}()\n//同上\n1 && function fn(){\n    console.log(123)\n}()\n//同上\n0 || function fn(){\n    console.log(123)\n}()\n\n// 原因：不难理解，此时的+，-应理解为正，负号，经过+之后函数声明变成了表达式，那么理所应当是可以执行的。\n// 同理：-（负号） 和 !（取非），&& 和 || 都可以使函数声明变成表达式。还有很多其他的方式可以实现此效果，请自行探索\n")])])]),a("p",[t._v("接下来，"),a("strong",[t._v("重点来了")]),t._v("，上面扯那么多跟"),a("strong",[t._v("立即函数表达式")]),t._v("有什么关系呢？？各位请上眼：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 写法一：\n(function(){\n    console.log(123)\n}())\n\n// 写法二：\n(function(){\n    console.log(123)\n})()\n\n//原理：括号里面的内容本身就会被识别为表达式（写法一的形成），最外层的括号()加上里面的内容就也是一个表达式（写法二的形成）。\n")])])]),a("p",[t._v("呼呼呼~~~终于圆过来了，各位看到这里是不是有种“你小子不会是骗我的吧”，“我信你个鬼，你这个糟老头子坏得很”这样的感觉，那欢迎各位自行验证，也欢迎来杠，闲话少说，下一个规则：")]),t._v(" "),a("h3",{attrs:{id:"规则二：能被执行符号-执行的表达式，立即执行之后，相应的函数名字就会被系统忽略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#规则二：能被执行符号-执行的表达式，立即执行之后，相应的函数名字就会被系统忽略"}},[t._v("#")]),t._v(" 规则二：能被执行符号()执行的表达式，立即执行之后，相应的函数名字就会被系统忽略")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// example 4 : \n// result    : 123\nvar test = function(){\n    console.log(123)\n}()\nconsole.log(test)  // undefined\n//上述函数表达式立即执行之后，系统会忽略这个test，同时此函数会被释放，那这样就相当于var test没有赋值，打印出来当然是undefined\n\n// example 5 : \n// result    :\n(function test(){\n    console.log(123)\n}())\nconsole.log(test) // Uncaught ReferenceError: test is not defined\n//立即执行函数会忽略函数名，那么test自然是未声明也未定义的，报错也是理所应当啦。\n")])])]),a("p",[t._v("规则二就是立即执行函数不声明函数名的原因，因为没有意义。。。")]),t._v(" "),a("h4",{attrs:{id:"一道恶心的笔试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一道恶心的笔试题"}},[t._v("#")]),t._v(" 一道恶心的笔试题")]),t._v(" "),a("p",[t._v("以下是某司曾经出过的一道贼恶心的面试题，划重点！！！")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 面试题：如下函数会得出什么结果\nfunction add(a,b,c){\n    console.log(a+b+c)\n}(1,2,3)\n\n// nothing\n\n")])])]),a("p",[t._v("经过各位的思考，可能会得出“这是函数声明，并不能被执行符号()执行，所以会报语法错误”这样的结论，但是实际结果却是 nothing，也就是啥都没做，啥结果都没有。。。。。。这能忍？？？“你小子果然在骗我！！”“糟老头子果然坏得很！！”")]),t._v(" "),a("p",[t._v("别急别急，听我再圆回来：在这个例子里面"),a("strong",[t._v("JavaScript引擎")]),t._v("执行到(1,2,3)的时候就会想，如果我把这玩意识别成执行符号，那这小子的代码肯定该报错，那他肯定不能愉快的下班,也就不能陪女朋友玩，女朋友就会跟别人跑了，这小子就会注孤生。。。想到一系列严重的后果之后，"),a("strong",[t._v("JavaScript引擎")]),t._v("就觉得一行代码导致注孤生的结果太残忍了，那我能不能变通一下呢。。。想到了："),a("strong",[t._v("(1,2,3)我不认为它是执行符号，认为它是一条正常的语句就好啦，然后把函数和这个语句分开")]),t._v("，这样就不用报错，这小子也能愉快的下班陪女朋友。。。我果然是个通情达理的引擎！！")]),t._v(" "),a("p",[t._v("因此，上述函数还是可以正常调用的：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function add(a,b,c){\n    console.log(a+b+c)\n}(1,2,3)\n\nadd(1,2,3) // 6\n")])])]),a("h2",{attrs:{id:"应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[t._v("#")]),t._v(" 应用")]),t._v(" "),a("h3",{attrs:{id:"初始化操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化操作"}},[t._v("#")]),t._v(" 初始化操作")]),t._v(" "),a("p",[t._v("立即执行函数因其只执行一次就立即销毁的特性，可用来完成一些初始化操作，比如页面获取的数据处理，页面首次渲染等都可以放在立即执行函数中进行。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(function(){\n    getData()  ....获取后台数据\n    init()     ....初始化页面\n    \n}())\n")])])]),a("h3",{attrs:{id:"解决全局变量污染问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决全局变量污染问题"}},[t._v("#")]),t._v(" 解决全局变量污染问题")]),t._v(" "),a("p",[t._v("立即执行函数会创建自己独立于全局的作用域，在里面定义的变量不会影响到全局变量。Jquery就应用了这个特性，同时也是JavaScript设计模式中"),a("a",{attrs:{href:"https://www.w3cschool.cn/zobyhd/to49mozt.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("模块化模式"),a("OutboundLink")],1),t._v("的原理。")]),t._v(" "),a("p",[a("strong",[t._v("Thats all！！！")])]),t._v(" "),a("h2",{attrs:{id:"写在最后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写在最后"}},[t._v("#")]),t._v(" 写在最后")]),t._v(" "),a("p",[t._v("这是小弟的第一篇文章，如有总结的不对的地方还请各位大佬指出（认怂），另外，小弟后续会更新一些学习总结，感兴趣可以收藏一下，毕竟大佬的文章看多了也看看菜鸡的文章找找信心嘛 -_-")]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ol",[a("li",[t._v("姬成的"),a("a",{attrs:{href:"https://ke.qq.com/course/231577?taid=1464781416663193",target:"_blank",rel:"noopener noreferrer"}},[t._v("渡一教育-JavaScript权威课堂"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=s.exports}}]);